import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

class BatteryPack:
    def __init__(self, thermal_mass, initial_temp, ambient_temp, heat_generation):
        """
        Initialize the battery pack parameters.
        
        :param thermal_mass: Thermal mass of the battery pack (J/°C)
        :param initial_temp: Initial temperature of the battery pack (°C)
        :param ambient_temp: Ambient temperature (°C)
        :param heat_generation: Heat generated by the battery (W)
        """
        self.thermal_mass = thermal_mass
        self.current_temp = initial_temp
        self.ambient_temp = ambient_temp
        self.heat_generation = heat_generation

class BTMS:
    def __init__(self, battery, system_type, airflow_rate, specific_heat_air=1005, efficiency=1.0):
        """
        Initialize the BTMS system.
        
        :param battery: Instance of BatteryPack
        :param system_type: Type of BTMS ('Passive', 'Active', 'HeatRecovery')
        :param airflow_rate: Airflow rate (m^3/s)
        :param specific_heat_air: Specific heat capacity of air (J/(kg·°C))
        :param efficiency: Efficiency factor for heat exchange
        """
        self.battery = battery
        self.system_type = system_type
        self.airflow_rate = airflow_rate
        self.specific_heat_air = specific_heat_air
        self.efficiency = efficiency
        self.air_density = 1.225  # kg/m^3 at sea level
        self.power_consumption = 0  # To be calculated for Active systems

    def calculate_heat_transfer(self, delta_temp):
        """
        Calculate the heat transfer based on airflow and temperature difference.
        
        :param delta_temp: Temperature difference between battery and air (°C)
        :return: Heat transfer rate (W)
        """
        mass_flow_rate = self.air_density * self.airflow_rate  # kg/s
        heat_transfer = mass_flow_rate * self.specific_heat_air * delta_temp * self.efficiency
        return heat_transfer

    def update_temperature(self, time_step):
        """
        Update the battery temperature based on heat generation and heat transfer.
        
        :param time_step: Time step for the simulation (s)
        """
        # Determine the temperature difference
        delta_temp = self.battery.current_temp - self.battery.ambient_temp

        # Calculate heat transfer based on system type
        if self.system_type == 'Passive':
            heat_transfer = self.calculate_heat_transfer(delta_temp)
        elif self.system_type == 'Active':
            # Active systems can adjust airflow or have higher efficiency
            self.power_consumption = 100  # Example power consumption in Watts
            heat_transfer = self.calculate_heat_transfer(delta_temp) * 1.5  # Assume higher efficiency
        elif self.system_type == 'HeatRecovery':
            # Heat recovery systems reuse some heat, improving efficiency
            heat_transfer = self.calculate_heat_transfer(delta_temp) * 1.2
            self.power_consumption = 80  # Lower power consumption due to heat recovery
        else:
            raise ValueError("Invalid system type. Choose 'Passive', 'Active', or 'HeatRecovery'.")

        # Net heat added to the battery
        net_heat = self.battery.heat_generation - heat_transfer  # W

        # Update temperature
        delta_T = (net_heat * time_step) / self.battery.thermal_mass
        self.battery.current_temp += delta_T

        return heat_transfer, self.power_consumption

def simulate_btms(system_type, total_time=3600, time_step=1):
    """
    Simulate the BTMS over a period of time.
    
    :param system_type: Type of BTMS ('Passive', 'Active', 'HeatRecovery')
    :param total_time: Total simulation time in seconds
    :param time_step: Time step in seconds
    :return: Time array, Temperature array, Heat transfer array, Power consumption array
    """
    # Initialize battery and BTMS parameters
    battery = BatteryPack(
        thermal_mass=500000,      # Example thermal mass in J/°C
        initial_temp=25.0,        # Initial temperature in °C
        ambient_temp=25.0,        # Ambient temperature in °C
        heat_generation=200       # Heat generation in W
    )

    btms = BTMS(
        battery=battery,
        system_type=system_type,
        airflow_rate=0.05          # Example airflow rate in m^3/s
    )

    # Initialize arrays to store simulation data
    time_array = np.arange(0, total_time, time_step)
    temp_array = []
    heat_transfer_array = []
    power_consumption_array = []

    for t in time_array:
        temp_array.append(btms.battery.current_temp)
        heat_transfer, power = btms.update_temperature(time_step)
        heat_transfer_array.append(heat_transfer)
        power_consumption_array.append(power)

    return time_array, np.array(temp_array), np.array(heat_transfer_array), np.array(power_consumption_array)

def analyze_performance(simulation_results):
    """
    Analyze and compare the performance metrics of different BTMS configurations.
    
    :param simulation_results: Dictionary containing simulation data for each system type
    :return: DataFrame with performance metrics
    """
    performance_data = {
        'System Type': [],
        'Average Battery Temperature (°C)': [],
        'Maximum Battery Temperature (°C)': [],
        'Minimum Battery Temperature (°C)': [],
        'Total Heat Transferred (J)': [],
        'Total Energy Consumed (J)': [],
        'Energy Efficiency (J/W)': []
    }

    for system, results in simulation_results.items():
        time, temp, heat_transfer, power = results
        total_heat_transferred = np.sum(heat_transfer) * (time[1] - time[0])  # J
        total_energy_consumed = np.sum(power) * (time[1] - time[0])         # J
        energy_efficiency = total_heat_transferred / total_energy_consumed if total_energy_consumed > 0 else np.nan

        performance_data['System Type'].append(system)
        performance_data['Average Battery Temperature (°C)'].append(np.mean(temp))
        performance_data['Maximum Battery Temperature (°C)'].append(np.max(temp))
        performance_data['Minimum Battery Temperature (°C)'].append(np.min(temp))
        performance_data['Total Heat Transferred (J)'].append(total_heat_transferred)
        performance_data['Total Energy Consumed (J)'].append(total_energy_consumed)
        performance_data['Energy Efficiency (J/W)'].append(energy_efficiency)

    performance_df = pd.DataFrame(performance_data)
    return performance_df

def plot_performance(performance_df):
    """
    Plot the performance metrics for different BTMS configurations.
    
    :param performance_df: DataFrame containing performance metrics
    """
    # Attempt to use 'seaborn-darkgrid' style, fallback to 'ggplot' if unavailable
    try:
        plt.style.use('seaborn-darkgrid')
    except OSError:
        print("Warning: 'seaborn-darkgrid' style not found. Using 'ggplot' instead.")
        plt.style.use('ggplot')

    # Plot Average Battery Temperature
    plt.figure(figsize=(10,6))
    plt.bar(performance_df['System Type'], performance_df['Average Battery Temperature (°C)'], color=['skyblue', 'salmon', 'lightgreen'])
    plt.xlabel('BTMS Configuration')
    plt.ylabel('Average Battery Temperature (°C)')
    plt.title('Average Battery Temperature by BTMS Configuration')
    plt.show()

    # Plot Total Heat Transferred
    plt.figure(figsize=(10,6))
    plt.bar(performance_df['System Type'], performance_df['Total Heat Transferred (J)'], color=['skyblue', 'salmon', 'lightgreen'])
    plt.xlabel('BTMS Configuration')
    plt.ylabel('Total Heat Transferred (J)')
    plt.title('Total Heat Transferred by BTMS Configuration')
    plt.show()

    # Plot Total Energy Consumed
    plt.figure(figsize=(10,6))
    plt.bar(performance_df['System Type'], performance_df['Total Energy Consumed (J)'], color=['skyblue', 'salmon', 'lightgreen'])
    plt.xlabel('BTMS Configuration')
    plt.ylabel('Total Energy Consumed (J)')
    plt.title('Total Energy Consumed by BTMS Configuration')
    plt.show()

    # Plot Energy Efficiency
    plt.figure(figsize=(10,6))
    plt.bar(performance_df['System Type'], performance_df['Energy Efficiency (J/W)'], color=['skyblue', 'salmon', 'lightgreen'])
    plt.xlabel('BTMS Configuration')
    plt.ylabel('Energy Efficiency (J/W)')
    plt.title('Energy Efficiency by BTMS Configuration')
    plt.show()


def main():
    systems = ['Passive', 'Active', 'HeatRecovery']
    simulation_results = {}

    total_time = 7200  # 2 hours in seconds
    time_step = 1       # 1 second

    for system in systems:
        time, temp, heat_transfer, power = simulate_btms(system_type=system, total_time=total_time, time_step=time_step)
        simulation_results[system] = (time, temp, heat_transfer, power)

    # Analyze performance
    performance_df = analyze_performance(simulation_results)
    print("BTMS Performance Comparison:")
    print(performance_df)

    # Plot performance metrics
    plot_performance(performance_df)

    # Optionally, save the performance data to a CSV file
    performance_df.to_csv('btms_performance_comparison.csv', index=False)
    print("\nPerformance data saved to 'btms_performance_comparison.csv'.")

if __name__ == "__main__":
    main()
